# Brooklyn Data Summary

The main assessment for analytics is from SQL query in the current folder named "brooklyn_part1.sql". 
The SQL query in the current folder named "brooklyn_test.sql" provides reasoning for missing/null data for
product data and categories. 

__Contents:__

- [Part I - Cte1: order_details](#part-i---cte1-order_details)
- [Part I - Cte2: top_3_product_categories](#part-i---cte2-top_3_product_categories)
- [Part I - Cte3: product_revenue_order](#part-i---cte3-product_revenue_order)
- [Part I - Cte4: final_select](#part-i---cte4-final_select)
- [Part II - Explanation: brooklyn_test](#part-ii---explanation-brooklyn_test)


## Part I - Cte1: order_details

- **Purpose**: The order_details is creating a re-usable way to track customers and orders by joining
               brooklyndata.olist_orders_dataset, brooklyndata.olist_order_payments_dataset, and
               brooklyndata.olist_order_customer_dataset based on the given data definitions and relationships.
- **Description**: This creates order_purchase_date, orders_count, customers_making_orders_count,
                   and revenue_usd. The primary key of this CTE is set on order_purchase_date.
- **Code**:
  ```sql
  SELECT
        DATE_TRUNC('day', o.order_purchase_timestamp) AS order_purchase_date,
        COUNT(DISTINCT o.order_id) AS orders_count,
        COUNT(DISTINCT oc.customer_id) AS customers_making_orders_count,
        SUM(op.payment_value) AS revenue_usd
    FROM
        brooklyndata.olist_orders_dataset o
    INNER JOIN
        brooklyndata.olist_order_payments_dataset op
    ON
        o.order_id = op.order_id
    INNER JOIN
        brooklyndata.olist_order_customer_dataset oc
    ON
        o.customer_id = oc.customer_id
    GROUP BY DATE_TRUNC('day', o.order_purchase_timestamp)
# Part I - Cte2: top_3_product_categories

- **Purpose**: The top_3_product_categories CTE is designed to track data related to product categories with a focus on revenue. It extracts information from various tables, including brooklyndata.olist_orders_dataset, brooklyndata.olist_order_items_dataset, and brooklyndata.product_category_name_translation, based on the provided data definitions and relationships.

- **Description**: This CTE generates the following key metrics:
  - `order_purchase_date`: The date of the order, truncated to day granularity.
  - `product_category_name`: The name of the product category.
  - `category_revenue`: The total revenue generated by products in the specified category.

- **Primary Key**: The primary key of this CTE is set on `order_purchase_date`.

- **SQL Code**:
  ```sql
  SELECT
      DATE_TRUNC('day', o.order_purchase_timestamp) AS order_purchase_date,
      pc.product_category_name,
      SUM(oi.price * oi.order_item_id) AS category_revenue
  FROM
      brooklyndata.olist_orders_dataset o
  INNER JOIN
      brooklyndata.olist_order_items_dataset oi
  ON
      o.order_id = oi.order_id
  INNER JOIN
      brooklyndata.olist_products_dataset p
  ON
      oi.product_id = p.product_id
  LEFT JOIN
      brooklyndata.product_category_name_translation pc
  ON
      p.product_category_name = pc.product_category_name
  GROUP BY
      DATE_TRUNC('day', o.order_purchase_timestamp),
      pc.product_category_name
  ORDER BY
      order_purchase_date,
      category_revenue DESC
## Part I - Cte3: product_revenue_order

- **Purpose**: The product_revenue_order is creating a cte to create
               order_purchase_date, product_category_name, category_revenue, and row_number
               based on order_purchase_date within descending category_revenue.  
               This cte is created from top_3_product_categories, with lowest row_number 
               representing the highest category revenue for the specific order dates.
- **Description**: This creates order_purchase_date, product_category_name, category_revenue, and row_number. 
                   The primary key of this CTE is set on order_purchase_date.
- **Code**:
  ```sql
        SELECT
            order_purchase_date,
            product_category_name,
            category_revenue,
            ROW_NUMBER() OVER (PARTITION BY order_purchase_date ORDER BY category_revenue DESC) AS row_num
        FROM
            top_3_product_categories
## Part I - Cte4: final_select
- **Purpose**: The final select creates the necessary field columns from the above ctes 
               for order_purchase_date, orders_count, customers_making_orders_count,
               revenue_usd, average_revenue_per_order_usd, top_3_product_categories_by_revenue,
               and top_3_product_categories_revenue_percentage.
               Formulas are created to create double decimal precision for revenue_usd,
               average_revenue_per_order_usd, and top_3_product_categories_revenue_percentage
               based on key order_purchase_date.  
- **Description**: This creates data based on requirements from assessment part I.
                   The primary key of this CTE is set on order_purchase_date.
- **Code**:
```sql
SELECT
    od.order_purchase_date,
    od.orders_count,
    od.customers_making_orders_count,
    ROUND(CAST(od.revenue_usd AS numeric), 2)::double precision AS revenue_usd,
    CAST(AVG(CAST(od.revenue_usd AS numeric) / od.orders_count) AS double precision)::numeric(10,2) AS average_revenue_per_order_usd,
    STRING_AGG(t3pc.product_category_name, ', ') AS top_3_product_categories_by_revenue,
    STRING_AGG(
        (ROUND(CAST((CAST(t3pc.category_revenue AS numeric) / od.revenue_usd) * 100 AS numeric), 2))::text,
        ', '
    ) AS top_3_product_categories_revenue_percentage
FROM
    order_details od
LEFT JOIN
    product_revenue_order t3pc
ON
    od.order_purchase_date = t3pc.order_purchase_date AND t3pc.row_num <= 3
GROUP BY
    od.order_purchase_date, od.orders_count, od.customers_making_orders_count, od.revenue_usd
ORDER BY
    od.order_purchase_date DESC;
## Part II - Explanation: brooklyn_test
- **Purpose**: brooklyn_test is added to make sure that category revenue and/or category product name 
               is validated because of missing order_id from product category, causing the nulls when
               joined by the order_purchase_date, which may cause counts of products or categories to
               be misaligned. 
- **Questions**: For verification, there may be a need to understand more about the upstream process 
                 for tables products and category to make sure that these are updated appropriately.  
- **Additionals**: There are definitely additional information for further analysis.  These can include 
                   finding time series data between purchased and delivered and comparing to the delivery
                   time, and also supporting demographic analysis because of availability of customer
                   data using zipcode and region using state and city data.






